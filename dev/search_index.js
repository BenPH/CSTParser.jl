var documenterSearchIndex = {"docs":
[{"location":"index.html#","page":"Home","title":"Home","text":"CurrentModule = CSTParser","category":"page"},{"location":"index.html#CSTParser-1","page":"Home","title":"CSTParser","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"(Image: Dev) (Image: Project Status: Active - The project has reached a stable, usable state and is being actively developed.) (Image: ) (Image: codecov)","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"A parser for Julia using Tokenize that aims to extend the built-in parser by providing additional meta information along with the resultant AST.","category":"page"},{"location":"index.html#Installation-and-Usage-1","page":"Home","title":"Installation and Usage","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"CSTParser\")","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"using CSTParser","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"Documentation: (Image: Dev)","category":"page"},{"location":"index.html#Additional-Output-1","page":"Home","title":"Additional Output","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"EXPR's are iterable producing children in the order that they appear in the source code, including punctuation.\nExample:\nf(x) = x*2 becomes [f(x), =, x*2]\nf(x) becomes [f, (, x, )]\nThe byte span of each EXPR is stored allowing a mapping between byte position in the source code and the releveant parsed expression. The span of a single token includes any trailing whitespace, newlines or comments. This also allows for fast partial parsing of modified source code.\nFormatting hints are generated as the source code is parsed (e.g. mismatched indents for blocks, missing white space around operators).\nThe declaration of modules, functions, datatypes and variables are tracked and stored in the relevant hierarchical scopes attatched to the expressions that declare the scope. This allows for a mapping between any identifying symbol and the relevant code that it refers to.","category":"page"},{"location":"index.html#Structure-1","page":"Home","title":"Structure","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"Expressions are represented solely by the following types:","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"Parser.SyntaxNode\n  Parser.EXPR\n  Parser.INSTANCE\n    Parser.HEAD{K}\n    Parser.IDENTIFIER\n    Parser.KEYWORD{K}\n    Parser.LITERAL{K}\n    Parser.OPERATOR{P,K,dot}\n    Parser.PUNCTUATION\n  Parser.QUOTENODE","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"The K parameterisation refers to the kind of the associated token as specified by Tokenize.Tokens.Kind. The P and dot parameters for operators refers to the precedence of the operator and whether it is dotted (e.g. .+).","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"INSTANCEs represent singular objects that may have a concrete or implicit relation to a portion of the source text. In the the former case they have a span storing the width in bytes that they occupy in the source text, in the latter case their span is 0. Additionally, IDENTIFIERs store their value as a Symbol and LITERALs as a String.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"EXPR are equivalent to Base.Expr but have extra fields to store their span and any punctuation tokens.","category":"page"},{"location":"syntax.html#Syntax-Reference-1","page":"Syntax Reference","title":"Syntax Reference","text":"","category":"section"},{"location":"syntax.html#","page":"Syntax Reference","title":"Syntax Reference","text":"Modules = [CSTParser]\nPages   = [\"syntax.md\"]","category":"page"},{"location":"syntax.html#Main-1","page":"Syntax Reference","title":"Main","text":"","category":"section"},{"location":"syntax.html#","page":"Syntax Reference","title":"Syntax Reference","text":"Modules = [CSTParser]\nPages = readdir(\"../src\")","category":"page"},{"location":"syntax.html#CSTParser.parse_expression-Tuple{ParseState}","page":"Syntax Reference","title":"CSTParser.parse_expression","text":"parse_expression(ps)\n\nParses an expression until closer(ps) == true. Expects to enter the ParseState the token before the the beginning of the expression and ends on the last token.\n\nAcceptable starting tokens are:\n\nA keyword\nAn opening parentheses or brace.\nAn operator.\nAn instance (e.g. identifier, number, etc.)\nAn @.\n\n\n\n\n\n","category":"method"},{"location":"syntax.html#CSTParser.parse","page":"Syntax Reference","title":"CSTParser.parse","text":"parse(str, cont = false)\n\nParses the passed string. If cont is true then will continue parsing until the end of the string returning the resulting expressions in a TOPLEVEL block.\n\n\n\n\n\n","category":"function"},{"location":"syntax.html#CSTParser.parse_compound-Tuple{ParseState,CSTParser.EXPR}","page":"Syntax Reference","title":"CSTParser.parse_compound","text":"parse_compound(ps::ParseState, ret::EXPR)\n\nAttempts to parse a compound expression given the preceding expression ret.\n\n\n\n\n\n","category":"method"},{"location":"syntax.html#CSTParser.parse_doc-Tuple{ParseState}","page":"Syntax Reference","title":"CSTParser.parse_doc","text":"Used for top-level parsing - attaches documentation (such as this) to expressions.\n\n\n\n\n\n","category":"method"},{"location":"syntax.html#CSTParser.parse_paren-Tuple{ParseState}","page":"Syntax Reference","title":"CSTParser.parse_paren","text":"parse_paren(ps, ret)\n\nParses an expression starting with a (.\n\n\n\n\n\n","category":"method"},{"location":"syntax.html#CSTParser.remlineinfo!-Tuple{Any}","page":"Syntax Reference","title":"CSTParser.remlineinfo!","text":"remlineinfo!(x)\n\nRemoves line info expressions. (i.e. Expr(:line, 1))\n\n\n\n\n\n","category":"method"},{"location":"syntax.html#CSTParser.contributes_scope-Tuple{CSTParser.EXPR}","page":"Syntax Reference","title":"CSTParser.contributes_scope","text":"contributes_scope(x)\n\nChecks whether the body of x is included in the toplevel namespace.\n\n\n\n\n\n","category":"method"},{"location":"syntax.html#CSTParser.get_id-Tuple{CSTParser.EXPR}","page":"Syntax Reference","title":"CSTParser.get_id","text":"get_id(x)\n\nGet the IDENTIFIER name of a variable, possibly in the presence of type declaration operators.\n\n\n\n\n\n","category":"method"},{"location":"syntax.html#CSTParser.get_sig-Tuple{CSTParser.EXPR}","page":"Syntax Reference","title":"CSTParser.get_sig","text":"get_sig(x)\n\nReturns the full signature of function, macro and datatype definitions. Should only be called when has_sig(x) == true.\n\n\n\n\n\n","category":"method"},{"location":"syntax.html#CSTParser.lex_ws_comment-Tuple{Tokenize.Lexers.Lexer,Char}","page":"Syntax Reference","title":"CSTParser.lex_ws_comment","text":"lex_ws_comment(l::Lexer, c)\n\nHaving hit an initial whitespace/comment/semicolon continues collecting similar Chars until they end. Returns a WS token with an indication of newlines/ semicolons. Indicating a semicolons takes precedence over line breaks as the former is equivalent to the former in most cases.\n\n\n\n\n\n","category":"method"},{"location":"syntax.html#CSTParser.check_reformat-Tuple{}","page":"Syntax Reference","title":"CSTParser.check_reformat","text":"check_reformat()\n\nReads and parses all files in current directory, applys formatting fixes and checks that the output AST remains the same.\n\n\n\n\n\n","category":"method"},{"location":"syntax.html#CSTParser.check_span","page":"Syntax Reference","title":"CSTParser.check_span","text":"check_span(x, neq = [])\n\nRecursively checks whether the span of an expression equals the sum of the span of its components. Returns a vector of failing expressions.\n\n\n\n\n\n","category":"function"},{"location":"syntax.html#CSTParser.compare-Tuple{Any,Any}","page":"Syntax Reference","title":"CSTParser.compare","text":"compare(x,y)\n\nRecursively checks whether two Base.Expr are the same. Returns unequal sub- expressions.\n\n\n\n\n\n","category":"method"},{"location":"syntax.html#CSTParser.@closer-Tuple{Any,Any,Any}","page":"Syntax Reference","title":"CSTParser.@closer","text":"@closer ps rule body\n\nContinues parsing closing on rule.\n\n\n\n\n\n","category":"macro"},{"location":"syntax.html#CSTParser.@default-Tuple{Any,Any}","page":"Syntax Reference","title":"CSTParser.@default","text":"@default ps body\n\nParses the next expression using default closure rules.\n\n\n\n\n\n","category":"macro"},{"location":"syntax.html#CSTParser.@nocloser-Tuple{Any,Any,Any}","page":"Syntax Reference","title":"CSTParser.@nocloser","text":"@nocloser ps rule body\n\nContinues parsing not closing on rule.\n\n\n\n\n\n","category":"macro"},{"location":"syntax.html#CSTParser.@precedence-Tuple{Any,Any,Any}","page":"Syntax Reference","title":"CSTParser.@precedence","text":"@precedence ps prec body\n\nContinues parsing binary operators until it hits a more loosely binding operator (with precdence lower than prec).\n\n\n\n\n\n","category":"macro"},{"location":"syntax.html#Components-1","page":"Syntax Reference","title":"Components","text":"","category":"section"},{"location":"syntax.html#","page":"Syntax Reference","title":"Syntax Reference","text":"Modules = [CSTParser]\nPages = readdir(\"../src/components\")","category":"page"},{"location":"syntax.html#CSTParser.parse_block","page":"Syntax Reference","title":"CSTParser.parse_block","text":"Continue parsing statements until an element of closers is hit (usually end). Statements are grouped in a Block EXPR.\n\n\n\n\n\n","category":"function"},{"location":"syntax.html#CSTParser.parse_call","page":"Syntax Reference","title":"CSTParser.parse_call","text":"parse_call(ps, ret)\n\nParses a function call. Expects to start before the opening parentheses and is passed the expression declaring the function name, ret.\n\n\n\n\n\n","category":"function"},{"location":"syntax.html#CSTParser.parse_comma_sep","page":"Syntax Reference","title":"CSTParser.parse_comma_sep","text":"Parses a comma separated list, optionally allowing for conversion of  assignment (=) expressions to Kw.\n\n\n\n\n\n","category":"function"},{"location":"syntax.html#CSTParser.parse_dot_mod","page":"Syntax Reference","title":"CSTParser.parse_dot_mod","text":"Helper function for parsing import/using statements.\n\n\n\n\n\n","category":"function"},{"location":"syntax.html#CSTParser.parse_generator-Tuple{ParseState,CSTParser.EXPR}","page":"Syntax Reference","title":"CSTParser.parse_generator","text":"parse_generator(ps)\n\nHaving hit for not at the beginning of an expression return a generator. Comprehensions are parsed as SQUAREs containing a generator.\n\n\n\n\n\n","category":"method"},{"location":"syntax.html#CSTParser.parse_iterator-Tuple{ParseState}","page":"Syntax Reference","title":"CSTParser.parse_iterator","text":"Parses an iterator, allowing for the preceding keyword outer. Returns an error expression if an invalid expression is parsed (anything other than =, in, ∈).\n\n\n\n\n\n","category":"method"},{"location":"syntax.html#CSTParser.parse_iterators","page":"Syntax Reference","title":"CSTParser.parse_iterators","text":"Parses a group of iterators e.g. used in a for loop or generator. Can allow for a succeeding Filter expression.\n\n\n\n\n\n","category":"function"},{"location":"syntax.html#CSTParser.parse_macrocall-Tuple{ParseState}","page":"Syntax Reference","title":"CSTParser.parse_macrocall","text":"parse_macrocall(ps)\n\nParses a macro call. Expects to start on the @.\n\n\n\n\n\n","category":"method"},{"location":"syntax.html#CSTParser.parse_parameters","page":"Syntax Reference","title":"CSTParser.parse_parameters","text":"Parses parameter arguments for a function call (e.g. following a semicolon).\n\n\n\n\n\n","category":"function"},{"location":"syntax.html#CSTParser.parse_if","page":"Syntax Reference","title":"CSTParser.parse_if","text":"parse_if(ps, ret, nested=false, puncs=[])\n\nParse an if block.\n\n\n\n\n\n","category":"function"},{"location":"syntax.html#CSTParser.parse_array","page":"Syntax Reference","title":"CSTParser.parse_array","text":"parse_array(ps)\n\nHaving hit '[' return either:\n\nA vect\nA vcat\nA comprehension\nAn array (vcat of hcats)\n\n\n\n\n\n","category":"function"},{"location":"syntax.html#CSTParser.parse_curly-Tuple{ParseState,CSTParser.EXPR}","page":"Syntax Reference","title":"CSTParser.parse_curly","text":"parse_curly(ps, ret)\n\nParses the juxtaposition of ret with an opening brace. Parses a comma seperated list.\n\n\n\n\n\n","category":"method"},{"location":"syntax.html#CSTParser.parse_ref-Tuple{ParseState,CSTParser.EXPR}","page":"Syntax Reference","title":"CSTParser.parse_ref","text":"parse_ref(ps, ret)\n\nHandles cases where an expression - ret - is followed by [. Parses the following bracketed expression and modifies it's .head appropriately.\n\n\n\n\n\n","category":"method"},{"location":"syntax.html#CSTParser.parse_tuple","page":"Syntax Reference","title":"CSTParser.parse_tuple","text":"parse_tuple(ps, ret)\n\nret is followed by a comma so tries to parse the rest of the tuple.\n\n\n\n\n\n","category":"function"},{"location":"syntax.html#CSTParser.parse_unary-Tuple{ParseState,CSTParser.EXPR}","page":"Syntax Reference","title":"CSTParser.parse_unary","text":"parse_unary(ps)\n\nHaving hit a unary operator at the start of an expression return a call.\n\n\n\n\n\n","category":"method"},{"location":"syntax.html#CSTParser.parse_string_or_cmd","page":"Syntax Reference","title":"CSTParser.parse_string_or_cmd","text":"parsestringor_cmd(ps)\n\nWhen trying to make an INSTANCE from a string token we must check for interpolating opoerators.\n\n\n\n\n\n","category":"function"}]
}
